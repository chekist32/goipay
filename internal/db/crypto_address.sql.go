// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: crypto_address.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCryptoAddress = `-- name: CreateCryptoAddress :one
INSERT INTO crypto_addresses(address, coin, is_occupied, user_id) VALUES ($1, $2, $3, $4)
RETURNING id, address, coin, is_occupied, user_id
`

type CreateCryptoAddressParams struct {
	Address    string
	Coin       CoinType
	IsOccupied bool
	UserID     pgtype.UUID
}

func (q *Queries) CreateCryptoAddress(ctx context.Context, arg CreateCryptoAddressParams) (CryptoAddress, error) {
	row := q.db.QueryRow(ctx, createCryptoAddress,
		arg.Address,
		arg.Coin,
		arg.IsOccupied,
		arg.UserID,
	)
	var i CryptoAddress
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.Coin,
		&i.IsOccupied,
		&i.UserID,
	)
	return i, err
}

const deleteAllCryptoAddressByUserIdAndCoin = `-- name: DeleteAllCryptoAddressByUserIdAndCoin :many
DELETE FROM crypto_addresses 
WHERE user_id = $1 AND coin = $2
RETURNING id, address, coin, is_occupied, user_id
`

type DeleteAllCryptoAddressByUserIdAndCoinParams struct {
	UserID pgtype.UUID
	Coin   CoinType
}

func (q *Queries) DeleteAllCryptoAddressByUserIdAndCoin(ctx context.Context, arg DeleteAllCryptoAddressByUserIdAndCoinParams) ([]CryptoAddress, error) {
	rows, err := q.db.Query(ctx, deleteAllCryptoAddressByUserIdAndCoin, arg.UserID, arg.Coin)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CryptoAddress
	for rows.Next() {
		var i CryptoAddress
		if err := rows.Scan(
			&i.ID,
			&i.Address,
			&i.Coin,
			&i.IsOccupied,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findNonOccupiedCryptoAddressAndLockByUserIdAndCoin = `-- name: FindNonOccupiedCryptoAddressAndLockByUserIdAndCoin :one
UPDATE crypto_addresses SET is_occupied = true
WHERE address = (
    SELECT address FROM crypto_addresses AS ca
    WHERE ca.user_id = $1 AND ca.coin = $2 AND ca.is_occupied = false 
    FOR UPDATE SKIP LOCKED
    LIMIT 1
)
RETURNING id, address, coin, is_occupied, user_id
`

type FindNonOccupiedCryptoAddressAndLockByUserIdAndCoinParams struct {
	UserID pgtype.UUID
	Coin   CoinType
}

func (q *Queries) FindNonOccupiedCryptoAddressAndLockByUserIdAndCoin(ctx context.Context, arg FindNonOccupiedCryptoAddressAndLockByUserIdAndCoinParams) (CryptoAddress, error) {
	row := q.db.QueryRow(ctx, findNonOccupiedCryptoAddressAndLockByUserIdAndCoin, arg.UserID, arg.Coin)
	var i CryptoAddress
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.Coin,
		&i.IsOccupied,
		&i.UserID,
	)
	return i, err
}

const updateIsOccupiedByCryptoAddress = `-- name: UpdateIsOccupiedByCryptoAddress :one
UPDATE crypto_addresses 
SET is_occupied = $2
WHERE address = $1
RETURNING id, address, coin, is_occupied, user_id
`

type UpdateIsOccupiedByCryptoAddressParams struct {
	Address    string
	IsOccupied bool
}

func (q *Queries) UpdateIsOccupiedByCryptoAddress(ctx context.Context, arg UpdateIsOccupiedByCryptoAddressParams) (CryptoAddress, error) {
	row := q.db.QueryRow(ctx, updateIsOccupiedByCryptoAddress, arg.Address, arg.IsOccupied)
	var i CryptoAddress
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.Coin,
		&i.IsOccupied,
		&i.UserID,
	)
	return i, err
}
